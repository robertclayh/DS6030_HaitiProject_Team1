VACATION = as.factor(VACATION),
SW = as.factor(SW),
SLOT = as.factor(SLOT),
GATE = as.factor(GATE)
)
# Set seed
set.seed(123)
# Split the data into training (75%) and test (25%)
airfares_split <- initial_split(Airfares, prop=0.75)
airfares_train <- training(airfares_split)
airfares_test <- testing(airfares_split)
# Prepare 10-fold CV
resamples <- vfold_cv(airfares_train, v=10)
# Define metrics
metrics <- metric_set(rmse, rsq, mae)
# Save pred
cv_control <- control_resamples(save_pred=TRUE)
# Define formula
formula <- FARE ~ COUPON + NEW + VACATION + SW + HI + S_INCOME +
E_INCOME + S_POP + E_POP + SLOT + GATE + DISTANCE + PAX
# Define recipe
rec <- recipe(formula, data=airfares_train) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_numeric_predictors())
# Define elasticnet
tune_lm_spec <- linear_reg(
mode="regression",
penalty=tune(),
mixture=tune()) %>%
set_engine("glmnet")
# Create workflow
tune_lm_wf <- workflow() %>%
add_recipe(rec) %>%
add_model(tune_lm_spec)
# Parameters
lm_params <- extract_parameter_set_dials(tune_lm_wf) %>%
update(
penalty = penalty(c(-2, 2)),
mixture = mixture(c(0, 1))
)
# Perform Bayesian optimization
set.seed(123)
tune_results_lm <- tune_bayes(
tune_lm_wf,
resamples = resamples,
metrics = metric_set(rmse, rsq, mae),
param_info = lm_params,
iter = 25,
control = control_bayes(no_improve = 5)
)
# Select only the single best parameter set
penalty_best <- select_best(tune_results_lm, metric = "rmse")
# Print best parameters in a kable
penalty_best %>%
knitr::kable(digits = 6, caption = "Best RMSE Parameters")
# Finalize workflow using the best RMSE parameters
final_lm_wf <- finalize_workflow(tune_lm_wf, penalty_best)
# Train final model
final_lm_model <- fit(final_lm_wf, data = airfares_train)
# Predict FARE on test set
predictions <- predict(final_lm_model, airfares_test) %>%
bind_cols(airfares_test)
# Compute metrics and format as a table
predictions %>%
metrics(truth = FARE, estimate = .pred) %>%
knitr::kable(digits = 4, caption = "Final Model Performance Metrics")
remove_columns <- c("Name", "Est Dia in M(min)",
"Semi Major Axis", "Jupiter Tisserand Invariant",
"Epoch Osculation", "Mean Motion", "Aphelion Dist",
"Equinox", "Orbiting Body", "Orbit Determination Date",
"Close Approach Date", "Epoch Date Close Approach",
"Miss Dist.(Astronomical)", "Miles per hour")
asteroids <- read_csv("https://gedeck.github.io/DS-6030/datasets/nasa.csv", show_col_types = FALSE) %>%
select(-all_of(remove_columns)) %>%
select(-contains("Relative Velocity")) %>%
select(-contains("Est Dia in KM")) %>%
select(-contains("Est Dia in Feet")) %>%
select(-contains("Est Dia in Miles")) %>%
select(-contains("Miss Dist.(lunar)")) %>%
select(-contains("Miss Dist.(kilometers)")) %>%
select(-contains("Miss Dist.(miles)")) %>%
distinct() %>%
mutate(Hazardous = as.factor(Hazardous))
set.seed(123)
# Split the data
asteroids_split <- initial_split(asteroids, prop = 0.8, strata = Hazardous)
# Train and test
asteroids_train <- training(asteroids_split)
asteroids_test <- testing(asteroids_split)
set.seed(123)
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pca(all_numeric_predictors(), num_comp = tune())
# Logreg model
log_reg_model <- logistic_reg(mode = "classification") %>%
set_engine("glm")
# Workflow
asteroids_workflow <- workflow() %>%
add_recipe(asteroids_recipe) %>%
add_model(log_reg_model)
# Define CV
asteroids_folds <- vfold_cv(asteroids_train, v = 10, strata = Hazardous)
# Define tuning
grid_vals <- tibble(num_comp = 1:14)
# Tune the model
tune_results <- tune_grid(
asteroids_workflow,
resamples = asteroids_folds,
grid = grid_vals,
metrics = metric_set(roc_auc)
)
# Visualize tuning results
autoplot(tune_results)
# Select the best number of components based on AUC
best_params <- select_best(tune_results, metric = "roc_auc")
print(best_params)
# Finalize the workflow with the best num_comp value
final_workflow <- finalize_workflow(asteroids_workflow, best_params)
# Train the final model on the full training set
final_model <- fit(final_workflow, data = asteroids_train)
# Evaluate on the test set
final_predictions <- predict(final_model, asteroids_test, type = "prob") %>%
bind_cols(asteroids_test)
# Compute performance metrics
final_metrics <- roc_auc(final_predictions, truth = Hazardous, .pred_Yes)
View(asteroids)
# Finalize the workflow with the best num_comp value
final_workflow <- finalize_workflow(asteroids_workflow, best_params)
# Train the final model on the full training set
final_model <- fit(final_workflow, data = asteroids_train)
# Evaluate on the test set
final_predictions <- predict(final_model, asteroids_test, type = "prob") %>%
bind_cols(asteroids_test)
# Compute performance metrics
final_metrics <- roc_auc(final_predictions, truth = Hazardous, .pred_TRUE)
print(final_metrics)
# Select the best number of components based on AUC
best_params <- select_best(tune_results, metric = "roc_auc")
show_best(tune_results, metric = "roc_auc", n=1)
set.seed(123)
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pca(all_numeric_predictors(), num_comp = tune())
# Logreg model
log_reg_model <- logistic_reg(mode = "classification") %>%
set_engine("glmnet")
# Workflow
asteroids_workflow <- workflow() %>%
add_recipe(asteroids_recipe) %>%
add_model(log_reg_model)
# Define CV
asteroids_folds <- vfold_cv(asteroids_train, v = 10, strata = Hazardous)
# Define tuning
grid_vals <- tibble(num_comp = 1:14)
# Tune the model
tune_results <- tune_grid(
asteroids_workflow,
resamples = asteroids_folds,
grid = grid_vals,
metrics = metric_set(roc_auc)
)
# Visualize tuning results
autoplot(tune_results)
set.seed(123)
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pca(all_numeric_predictors(), num_comp = tune())
# Logreg model
log_reg_model <- logistic_reg(mode = "classification") %>%
set_engine("glm")
# Workflow
asteroids_workflow <- workflow() %>%
add_recipe(asteroids_recipe) %>%
add_model(log_reg_model)
# Define CV
asteroids_folds <- vfold_cv(asteroids_train, v = 10, strata = Hazardous)
# Define tuning
grid_vals <- tibble(num_comp = 1:14)
# Tune the model
tune_results <- tune_grid(
asteroids_workflow,
resamples = asteroids_folds,
grid = grid_vals,
metrics = metric_set(roc_auc)
)
# Visualize tuning results
autoplot(tune_results)
# Select the best number of components based on AUC
best_params <- select_best(tune_results, metric = "roc_auc")
show_best(tune_results, metric = "roc_auc", n=1)
# Finalize the workflow with the best num_comp value
final_workflow <- finalize_workflow(asteroids_workflow, best_params)
# Train the final model on the full training set
final_model <- fit(final_workflow, data = asteroids_train)
# Evaluate on the test set
final_predictions <- predict(final_model, asteroids_test, type = "prob") %>%
bind_cols(asteroids_test)
# Compute performance metrics
final_metrics <- roc_auc(final_predictions, truth = Hazardous, .pred_TRUE)
print(final_metrics)
# Finalize the workflow with the best num_comp value
final_workflow <- finalize_workflow(asteroids_workflow, best_params)
# Train the final model on the full training set
final_model <- fit(final_workflow, data = asteroids_train)
# Evaluate on the test set
final_predictions <- predict(final_model, asteroids_test, type = "prob") %>%
bind_cols(asteroids_test)
# Compute performance metrics
final_metrics <- roc_auc(final_predictions, truth = Hazardous, .pred_TRUE, event_level = "second")
print(final_metrics)
set.seed(123)
library(plsmod)
install.packages(plsmod)
set.seed(123)
#library(plsmod)
library(BiocManager)
install.packages("BiocManager")
set.seed(123)
#library(plsmod)
library(BiocManager)
if (!requireNamespace("mixOmics", quietly = TRUE)) {
BiocManager::install("mixOmics")
}
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pls(all_numeric_predictors(), num_comp = tune())
set.seed(123)
library(plsmod)
install.packages("plsmod")
set.seed(123)
library(plsmod)
library(BiocManager)
if (!requireNamespace("mixOmics", quietly = TRUE)) {
BiocManager::install("mixOmics")
}
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pls(all_numeric_predictors(), num_comp = tune())
set.seed(123)
library(plsmod)
library(BiocManager)
if (!requireNamespace("mixOmics", quietly = TRUE)) {
BiocManager::install("mixOmics")
}
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pls(all_numeric_predictors(), num_comp = tune())
set.seed(123)
library(plsmod)
library(BiocManager)
if (!requireNamespace("mixOmics", quietly = TRUE)) {
BiocManager::install("mixOmics")
}
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pls(all_numeric_predictors(), outcome = all_outcomes(), num_comp = tune())
set.seed(123)
library(plsmod)
library(BiocManager)
if (!requireNamespace("mixOmics", quietly = TRUE)) {
BiocManager::install("mixOmics")
}
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pls(all_numeric_predictors(), outcome = all_outcomes(), num_comp = tune())
# Define model
log_reg_model <- logistic_reg(mode = "classification") %>%
set_engine("glm")
# WF
asteroids_workflow <- workflow() %>%
add_recipe(asteroids_recipe) %>%
add_model(log_reg_model)
# CV folds
asteroids_folds <- vfold_cv(asteroids_train, v = 10, strata = Hazardous)
# Tune grid
param_grid <- grid_regular(num_comp(range = c(1, 14)), levels = 14)
# Tune
tune_results <- tune_grid(
asteroids_workflow,
resamples = asteroids_folds,
grid = param_grid,
metrics = metric_set(roc_auc)
)
set.seed(123)
library(plsmod)
library(BiocManager)
if (!requireNamespace("mixOmics", quietly = TRUE)) {
BiocManager::install("mixOmics")
}
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pls(all_numeric_predictors(), outcome = all_outcomes(), num_comp = tune())
# Define model
log_reg_model <- logistic_reg(mode = "classification") %>%
set_engine("glm")
# WF
asteroids_workflow <- workflow() %>%
add_recipe(asteroids_recipe) %>%
add_model(log_reg_model)
# CV folds
asteroids_folds <- vfold_cv(asteroids_train, v = 10, strata = Hazardous)
# Tune grid
param_grid <- grid_regular(num_comp(range = c(1, 14)), levels = 14)
# Tune
tune_results <- tune_grid(
asteroids_workflow,
resamples = asteroids_folds,
grid = param_grid,
metrics = metric_set(roc_auc)
)
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
knitr::opts_chunk$set(fig.align="center", fig.pos="H")
#| message: FALSE
library(tidymodels)
library(tidyverse)
library(discrim)
library(patchwork)
#| cache: FALSE
#| message: false
library(doParallel)
cl <- makePSOCKcluster(parallel::detectCores(logical = FALSE))
registerDoParallel(cl)
#| message: FALSE
Airfares <- readr::read_csv(
"https://gedeck.github.io/DS-6030/datasets/homework/Airfares.csv.gz")
# Removed S_CODE and E_CODE as the data is incomplete and is represented in
# S_CITY and E_CITY
Airfares <- Airfares %>% select(-S_CODE, -E_CODE)
Airfares <- Airfares %>% mutate(
VACATION = as.factor(VACATION),
SW = as.factor(SW),
SLOT = as.factor(SLOT),
GATE = as.factor(GATE)
)
# Set seed
set.seed(123)
# Split the data into training (75%) and test (25%)
airfares_split <- initial_split(Airfares, prop=0.75)
airfares_train <- training(airfares_split)
airfares_test <- testing(airfares_split)
# Prepare 10-fold CV
resamples <- vfold_cv(airfares_train, v=10)
# Define metrics
metrics <- metric_set(rmse, rsq, mae)
# Save pred
cv_control <- control_resamples(save_pred=TRUE)
# Define formula
formula <- FARE ~ COUPON + NEW + VACATION + SW + HI + S_INCOME +
E_INCOME + S_POP + E_POP + SLOT + GATE + DISTANCE + PAX
# Define recipe
rec <- recipe(formula, data=airfares_train) %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_numeric_predictors())
# Define elasticnet
tune_lm_spec <- linear_reg(
mode="regression",
penalty=tune(),
mixture=tune()) %>%
set_engine("glmnet")
# Create workflow
tune_lm_wf <- workflow() %>%
add_recipe(rec) %>%
add_model(tune_lm_spec)
# Parameters
lm_params <- extract_parameter_set_dials(tune_lm_wf) %>%
update(
penalty = penalty(c(-2, 2)),
mixture = mixture(c(0, 1))
)
# Perform Bayesian optimization
set.seed(123)
tune_results_lm <- tune_bayes(
tune_lm_wf,
resamples = resamples,
metrics = metric_set(rmse, rsq, mae),
param_info = lm_params,
iter = 25,
control = control_bayes(no_improve = 5)
)
# Select only the single best parameter set
penalty_best <- select_best(tune_results_lm, metric = "rmse")
# Print best parameters in a kable
penalty_best %>%
knitr::kable(digits = 6, caption = "Best RMSE Parameters")
# Finalize workflow using the best RMSE parameters
final_lm_wf <- finalize_workflow(tune_lm_wf, penalty_best)
# Train final model
final_lm_model <- fit(final_lm_wf, data = airfares_train)
# Predict FARE on test set
predictions <- predict(final_lm_model, airfares_test) %>%
bind_cols(airfares_test)
# Compute metrics and format as a table
predictions %>%
metrics(truth = FARE, estimate = .pred) %>%
knitr::kable(digits = 4, caption = "Final Model Performance Metrics")
remove_columns <- c("Name", "Est Dia in M(min)",
"Semi Major Axis", "Jupiter Tisserand Invariant",
"Epoch Osculation", "Mean Motion", "Aphelion Dist",
"Equinox", "Orbiting Body", "Orbit Determination Date",
"Close Approach Date", "Epoch Date Close Approach",
"Miss Dist.(Astronomical)", "Miles per hour")
asteroids <- read_csv("https://gedeck.github.io/DS-6030/datasets/nasa.csv", show_col_types = FALSE) %>%
select(-all_of(remove_columns)) %>%
select(-contains("Relative Velocity")) %>%
select(-contains("Est Dia in KM")) %>%
select(-contains("Est Dia in Feet")) %>%
select(-contains("Est Dia in Miles")) %>%
select(-contains("Miss Dist.(lunar)")) %>%
select(-contains("Miss Dist.(kilometers)")) %>%
select(-contains("Miss Dist.(miles)")) %>%
distinct() %>%
mutate(Hazardous = as.factor(Hazardous))
set.seed(123)
# Split the data
asteroids_split <- initial_split(asteroids, prop = 0.8, strata = Hazardous)
# Train and test
asteroids_train <- training(asteroids_split)
asteroids_test <- testing(asteroids_split)
set.seed(123)
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pca(all_numeric_predictors(), num_comp = tune())
# Logreg model
log_reg_model <- logistic_reg(mode = "classification") %>%
set_engine("glm")
# Workflow
asteroids_workflow <- workflow() %>%
add_recipe(asteroids_recipe) %>%
add_model(log_reg_model)
# Define CV
asteroids_folds <- vfold_cv(asteroids_train, v = 10, strata = Hazardous)
# Define tuning
grid_vals <- tibble(num_comp = 1:14)
# Tune the model
tune_results <- tune_grid(
asteroids_workflow,
resamples = asteroids_folds,
grid = grid_vals,
metrics = metric_set(roc_auc)
)
# Visualize
autoplot(tune_results)
# Select the best number of components based on AUC
best_params <- select_best(tune_results, metric = "roc_auc")
show_best(tune_results, metric = "roc_auc", n=1)
# Finalize wf
final_workflow <- finalize_workflow(asteroids_workflow, best_params)
# Train
final_model <- fit(final_workflow, data = asteroids_train)
# Evaluate on test
final_predictions <- predict(final_model, asteroids_test, type = "prob") %>%
bind_cols(asteroids_test)
# Compute roc auc
final_metrics <- roc_auc(final_predictions, truth = Hazardous, .pred_TRUE, event_level = "second")
print(final_metrics)
set.seed(123)
library(plsmod)
library(BiocManager)
if (!requireNamespace("mixOmics", quietly = TRUE)) {
BiocManager::install("mixOmics")
}
# Recipe
asteroids_recipe <- recipe(Hazardous ~ ., data = asteroids_train) %>%
step_normalize(all_numeric_predictors()) %>%
step_pls(all_numeric_predictors(), outcome = all_outcomes(), num_comp = tune())
# Define model
log_reg_model <- logistic_reg(mode = "classification") %>%
set_engine("glm")
# WF
asteroids_workflow <- workflow() %>%
add_recipe(asteroids_recipe) %>%
add_model(log_reg_model)
# CV folds
asteroids_folds <- vfold_cv(asteroids_train, v = 10, strata = Hazardous)
# Tune grid
param_grid <- grid_regular(num_comp(range = c(1, 14)), levels = 14)
# Tune
tune_results <- tune_grid(
asteroids_workflow,
resamples = asteroids_folds,
grid = param_grid,
metrics = metric_set(roc_auc)
)
# Vis
autoplot(tune_results)
# Select the best number of components based on AUC
best_params <- select_best(tune_results, metric = "roc_auc")
show_best(tune_results, metric = "roc_auc", n=1)
# Finalize wf
final_workflow <- finalize_workflow(asteroids_workflow, best_params)
# Train
final_model <- fit(final_workflow, data = asteroids_train)
# Evaluate on test
final_predictions <- predict(final_model, asteroids_test, type = "prob") %>%
bind_cols(asteroids_test)
# Compute roc auc
final_metrics <- roc_auc(final_predictions, truth = Hazardous, .pred_TRUE, event_level = "second")
print(final_metrics)
stopCluster(cl)
registerDoSEQ()
setwd("~/Documents/MSDS/DS6030/DS6030_HaitiProject_Team1")
