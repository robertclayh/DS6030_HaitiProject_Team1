read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(6, 6, 10, 12, 12, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8,
col_types = cols(
ID    = col_double(),
X     = col_character(),
Y     = col_character(),
Map_X = col_double(),
Map_Y = col_double(),
Lat   = col_double(),
Lon   = col_double(),
B1    = col_double(),
B2    = col_double(),
B3    = col_double()
)
) %>%
# Extract class label from the file name (e.g., "NON_Blue_Tarps", "NOT_Blue_Tarps", or "Blue_Tarps")
mutate(Class = str_extract(.x, "(NON_Blue_Tarps|NOT_Blue_Tarps|Blue_Tarps)"))
})
View(all_data)
problems(all_data)
problems(all_data)
check <- problems(all_data)
check
files <- c(
"orthovnir057_ROI_NON_Blue_Tarps.txt",
"orthovnir078_ROI_NON_Blue_Tarps.txt",
"orthovnir067_ROI_NOT_Blue_Tarps.txt",
"orthovnir069_ROI_NOT_Blue_Tarps.txt"
)
all_data <- map_dfr(files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(6, 6, 10, 12, 12, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = str_extract(.x, "(NON_Blue_Tarps|NOT_Blue_Tarps)"))
})
glimpse(all_data)
View(all_data)
# Define your Blue tarps files
blue_files <- c(
"orthovnir069_ROI_Blue_Tarps.txt",
"orthovnir067_ROI_Blue_Tarps.txt",
"orthovnir078_ROI_Blue_Tarps.txt"
)
# 1. Inspect the first 10 lines of each file
blue_samples <- map(blue_files, ~ read_lines(.x, n_max = 10))
names(blue_samples) <- blue_files
# Print the sample lines for manual inspection
blue_samples
# 2. Attempt to auto-detect column widths using fwf_empty on one file
# (Adjust the skip value if needed; here we skip 8 rows as before)
example_lines <- read_lines(blue_files[1], skip = 8, n_max = 100)
auto_widths <- fwf_empty(example_lines, skip_empty_rows = FALSE)
# Use one of the Blue tarps files for inspection:
blue_file <- "orthovnir069_ROI_Blue_Tarps.txt"
# Read the first data line (after skipping 8 header lines)
first_line <- read_lines(blue_file, skip = 8, n_max = 1)
# Function to print a line with position indices on top
print_line_with_indices <- function(line) {
n <- nchar(line)
# Create a string of position numbers; adjust spacing as needed
positions <- paste(sprintf("%2d", 1:n), collapse = " ")
cat("Positions:\n", positions, "\n")
cat("Line:     \n", line, "\n")
}
# Print the line with indices
print_line_with_indices(first_line)
blue_files <- c(
"orthovnir069_ROI_Blue_Tarps.txt",
"orthovnir067_ROI_Blue_Tarps.txt",
"orthovnir078_ROI_Blue_Tarps.txt"
)
blue_data <- map_dfr(blue_files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(6, 6, 10, 12, 12, 10, 12, 5, 5, 5),  # Adjust these widths as needed
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = "Blue_Tarps")
})
glimpse(blue_data)
View(blue_data)
View(data)
blue_files <- c(
"orthovnir069_ROI_Blue_Tarps.txt",
"orthovnir067_ROI_Blue_Tarps.txt",
"orthovnir078_ROI_Blue_Tarps.txt"
)
blue_data <- map_dfr(blue_files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(5, 6, 10, 12, 12, 10, 12, 5, 5, 5),  # Adjust these widths as needed
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = "Blue_Tarps")
})
glimpse(blue_data)
blue_files <- c(
"orthovnir069_ROI_Blue_Tarps.txt",
"orthovnir067_ROI_Blue_Tarps.txt",
"orthovnir078_ROI_Blue_Tarps.txt"
)
blue_data <- map_dfr(blue_files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(5, 6, 10, 12, 11, 10, 12, 5, 5, 5),  # Adjust these widths as needed
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = "Blue_Tarps")
})
glimpse(blue_data)
files <- c(
"orthovnir057_ROI_NON_Blue_Tarps.txt",
"orthovnir078_ROI_NON_Blue_Tarps.txt",
"orthovnir067_ROI_NOT_Blue_Tarps.txt",
"orthovnir069_ROI_NOT_Blue_Tarps.txt"
)
non_not_blue_data <- map_dfr(files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(6, 6, 10, 12, 12, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = str_extract(.x, "(NON_Blue_Tarps|NOT_Blue_Tarps)"))
})
#| message: FALSE
files <- c(
"orthovnir057_ROI_NON_Blue_Tarps.txt",
"orthovnir078_ROI_NON_Blue_Tarps.txt",
"orthovnir067_ROI_NOT_Blue_Tarps.txt",
"orthovnir069_ROI_NOT_Blue_Tarps.txt"
)
non_not_blue_data <- map_dfr(files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(6, 6, 10, 12, 12, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = str_extract(.x, "(NON_Blue_Tarps|NOT_Blue_Tarps)"))
})
holdout_data <- bind_rows(non_not_blue_data, blue_data) %>%
select(Lat, Lon, B1, B2, B3)
merged_data <- bind_rows(
non_not_blue_data %>% select(Lat, Lon, B1, B2, B3),
blue_data %>% select(Lat, Lon, B1, B2, B3)
)
glimpse(merged_data)
holdout_data <- bind_rows(
non_not_blue_data %>% select(Lat, Lon, B1, B2, B3),
blue_data %>% select(Lat, Lon, B1, B2, B3)
)
glimpse(holdout_data)
#| message: FALSE
files <- c(
"orthovnir057_ROI_NON_Blue_Tarps.txt",
"orthovnir078_ROI_NON_Blue_Tarps.txt",
"orthovnir067_ROI_NOT_Blue_Tarps.txt",
"orthovnir069_ROI_NOT_Blue_Tarps.txt"
)
non_not_blue_data <- map_dfr(files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(6, 6, 10, 12, 12, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = str_extract(.x, "(NON_Blue_Tarps|NOT_Blue_Tarps)"))
})
#| message: FALSE
blue_files <- c(
"orthovnir069_ROI_Blue_Tarps.txt",
"orthovnir067_ROI_Blue_Tarps.txt",
"orthovnir078_ROI_Blue_Tarps.txt"
)
blue_data <- map_dfr(blue_files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(5, 6, 10, 12, 11, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = "Blue_Tarps")
})
holdout_data <- bind_rows(
non_not_blue_data %>% select(Lat, Lon, B1, B2, B3),
blue_data %>% select(Lat, Lon, B1, B2, B3)
)
glimpse(holdout_data)
holdout_data <- bind_rows(
non_not_blue_data %>% select(Lat, Lon, B1, B2, B3, Class),
blue_data %>% select(Lat, Lon, B1, B2, B3, Class)
)
glimpse(holdout_data)
# Assuming holdout_data contains: Lat, Lon, B1, B2, B3
# Rename coordinate columns so that Lon becomes x and Lat becomes y
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
knitr::opts_chunk$set(fig.align="center", fig.pos="H")
#| cache: FALSE
#| message: FALSE
library(doParallel)
cl <- makePSOCKcluster(parallel::detectCores(logical = FALSE))
registerDoParallel(cl)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
#| message: FALSE
files <- c(
"orthovnir057_ROI_NON_Blue_Tarps.txt",
"orthovnir078_ROI_NON_Blue_Tarps.txt",
"orthovnir067_ROI_NOT_Blue_Tarps.txt",
"orthovnir069_ROI_NOT_Blue_Tarps.txt"
)
non_not_blue_data <- map_dfr(files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(6, 6, 10, 12, 12, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = str_extract(.x, "(NON_Blue_Tarps|NOT_Blue_Tarps)"))
})
#| message: FALSE
blue_files <- c(
"orthovnir069_ROI_Blue_Tarps.txt",
"orthovnir067_ROI_Blue_Tarps.txt",
"orthovnir078_ROI_Blue_Tarps.txt"
)
blue_data <- map_dfr(blue_files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(5, 6, 10, 12, 11, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = "Blue_Tarps")
})
holdout_data <- bind_rows(
non_not_blue_data %>% select(Lat, Lon, B1, B2, B3, Class),
blue_data %>% select(Lat, Lon, B1, B2, B3, Class)
)
glimpse(holdout_data)
# Assuming holdout_data contains: Lat, Lon, B1, B2, B3
# Rename coordinate columns so that Lon becomes x and Lat becomes y
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
# Create a raster from the data.
# The 'type = "xyz"' option treats the first two columns as coordinates and the rest as values.
r <- terra::rast(holdout_data_sp, type = "xyz", crs = "EPSG:4326")
# Convert to a spatial vector
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
v <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:4326")
# Create an empty raster with extent from the vector and resolution 0.1
r_empty <- terra::rast(ext(v), resolution = 0.1, crs = "EPSG:4326")
# Convert to a spatial vector
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
v <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:4326")
# Create an empty raster with extent from the vector and resolution 0.1
r_empty <- terra::rast(terra::ext(v), resolution = 0.1, crs = "EPSG:4326")
# Rasterize each band into the grid
r_b1 <- terra::rasterize(v, r_empty, field = "B1")
r_b2 <- terra::rasterize(v, r_empty, field = "B2")
r_b3 <- terra::rasterize(v, r_empty, field = "B3")
# Combine into a multi-layer raster
rgb_raster <- c(r_b1, r_b2, r_b3)
# Plot the RGB raster
terra::plotRGB(rgb_raster, r = 1, g = 2, b = 3)
# Adjust holdout_data so that x and y are exactly on a 0.1 grid.
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat) %>%
mutate(x = round(x, 1), y = round(y, 1))
# Now create the raster
r <- terra::rast(holdout_data_sp, type = "xyz", crs = "EPSG:4326")
View(holdout_data_sp)
# Convert to a spatial vector
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
v <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:4326")
# Create an empty raster with extent from the vector and resolution 0.1
r_empty <- terra::rast(terra::ext(v), resolution = 0.1, crs = "EPSG:4326")
# Rasterize each band into the grid
r_b1 <- terra::rasterize(v, r_empty, field = "B1")
r_b2 <- terra::rasterize(v, r_empty, field = "B2")
r_b3 <- terra::rasterize(v, r_empty, field = "B3")
View(holdout_data_sp)
# Combine into a multi-layer raster
rgb_raster <- c(r_b1, r_b2, r_b3)
# Plot the RGB raster
terra::plotRGB(rgb_raster, r = 1, g = 2, b = 3)
View(holdout_data)
# Convert to a spatial vector
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
v <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:4326")
# Create an empty raster with extent from the vector and resolution 0.1
r_empty <- terra::rast(terra::ext(v), resolution = 0.1, crs = "EPSG:4326")
# Rasterize each band into the grid
r_b1 <- terra::rasterize(v, r_empty, field = "B1")
r_b2 <- terra::rasterize(v, r_empty, field = "B2")
r_b3 <- terra::rasterize(v, r_empty, field = "B3")
# Combine into a multi-layer raster
rgb_raster <- c(r_b1, r_b2, r_b3)
# Plot the RGB raster
terra::plotRGB(rgb_raster, r = 1, g = 2, b = 3)
View(rgb_raster)
# Assume holdout_data has columns: Lat, Lon, B1, B2, B3.
# Rename for spatial coordinates
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
# Check coordinate ranges (helpful for debugging)
range_x <- range(holdout_data_sp$x)
range_y <- range(holdout_data_sp$y)
cat("X range:", range_x, "\n")
cat("Y range:", range_y, "\n")
# Convert the data frame to a spatial vector using terra:
v <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:4326")
# Create an extent from the vector.
e <- terra::ext(v)
cat("Extent:\n")
print(e)
# Create an empty raster with the extent and desired resolution (0.1)
r_empty <- terra::rast(e, resolution = 0.1, crs = "EPSG:4326")
# Rasterize each band. This assigns each cell the value of the point that falls into it.
r_b1 <- terra::rasterize(v, r_empty, field = "B1")
r_b2 <- terra::rasterize(v, r_empty, field = "B2")
r_b3 <- terra::rasterize(v, r_empty, field = "B3")
# Combine the bands into a multi-layer raster
rgb_raster <- c(r_b1, r_b2, r_b3)
# Plot the RGB composite: B1=red, B2=green, B3=blue
terra::plotRGB(rgb_raster, r = 1, g = 2, b = 3)
# First, rename your coordinate columns
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
# Create a spatial vector from your data in EPSG:4326 (WGS84)
v <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:4326")
# Reproject to UTM zone 18N (units in meters)
v_utm <- terra::project(v, "EPSG:32618")
# Check the new extent in UTM (in meters)
print(terra::ext(v_utm))
# Create an empty raster over the extent with a resolution of 0.1 m
r_empty_utm <- terra::rast(terra::ext(v_utm), resolution = 0.1, crs = "EPSG:32618")
# Rasterize each band from the UTM vector onto the empty raster
r_b1 <- terra::rasterize(v_utm, r_empty_utm, field = "B1")
r_b2 <- terra::rasterize(v_utm, r_empty_utm, field = "B2")
r_b3 <- terra::rasterize(v_utm, r_empty_utm, field = "B3")
# Combine the bands into a multi-layer raster
rgb_raster <- c(r_b1, r_b2, r_b3)
# Plot the RGB composite (B1 as red, B2 as green, B3 as blue)
terra::plotRGB(rgb_raster, r = 1, g = 2, b = 3)
# Process the holdout_data into a raster
holdout_data_sp <- holdout_data %>% rename(x = Lon, y = Lat)
v <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:4326")
v_utm <- terra::project(v, "EPSG:32618")
r_empty <- terra::rast(terra::ext(v_utm), resolution = 0.1, crs = "EPSG:32618")
r_b1 <- terra::rasterize(v_utm, r_empty, field = "B1")
r_b2 <- terra::rasterize(v_utm, r_empty, field = "B2")
r_b3 <- terra::rasterize(v_utm, r_empty, field = "B3")
rgb_raster <- terra::project(c(r_b1, r_b2, r_b3), "EPSG:4326")
# Create an interactive HTML map
m <- leaflet() %>%
addTiles() %>%
addRasterRGB(rgb_raster, r = 1, g = 2, b = 3, maxBytes = 4 * 1024^2)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
# Create an interactive HTML map
m <- leaflet() %>%
addTiles() %>%
addRasterRGB(rgb_raster, r = 1, g = 2, b = 3, maxBytes = 4 * 1024^2)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
# Create an interactive HTML map
m <- leaflet() %>%
addTiles() %>%
addRasterRGB(rgb_raster, r = 1, g = 2, b = 3, maxBytes = 4 * 1024^2)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
# Create an interactive HTML map
m <- leaflet() %>%
addTiles() %>%
addRasterRGB(rgb_raster, r = 1, g = 2, b = 3, maxBytes = 4 * 1024^2)
# Create an interactive HTML map
m <- leaflet() %>%
addTiles() %>%
leaflet::addRasterRGB(rgb_raster, r = 1, g = 2, b = 3, maxBytes = 4 * 1024^2)
install.packages("leaflet")
install.packages("leaflet")
# Create an interactive HTML map
m <- leaflet() %>%
addTiles() %>%
leaflet::addRasterRGB(rgb_raster, r = 1, g = 2, b = 3, maxBytes = 4 * 1024^2)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
# Create an interactive HTML map
m <- leaflet() %>%
addTiles() %>%
leaflet::addRasterRGB(rgb_raster, r = 1, g = 2, b = 3, maxBytes = 4 * 1024^2)
# Create an interactive HTML map
m <- leaflet() %>%
addTiles() %>%
leafem::addRasterRGB(rgb_raster, r = 1, g = 2, b = 3)
install.packages("stars")
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(stars)
# Convert the terra SpatRaster to a stars object
rgb_stars <- stars::st_as_stars(rgb_raster)
# Create an interactive HTML map using leaflet and leafem
m <- leaflet() %>%
addTiles() %>%
leafem::addRasterRGB(rgb_stars, r = 1, g = 2, b = 3)
# Convert the terra SpatRaster (rgb_raster) to a RasterBrick
rgb_brick <- raster::brick(rgb_raster)
# Create an interactive map using leaflet and addRasterRGB from leafem
m <- leaflet() %>%
addTiles() %>%
leafem::addRasterRGB(rgb_brick, r = 1, g = 2, b = 3)
# Convert holdout_data into a spatial vector (WGS84)
holdout_data_sp <- holdout_data %>%
rename(x = Lon, y = Lat)
v <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:4326")
# Reproject to UTM (EPSG:32618) so that resolution is in meters
v_utm <- terra::project(v, "EPSG:32618")
# Create an empty raster with 0.1 m resolution (disk-backed)
r_empty <- terra::rast(terra::ext(v_utm), resolution = 0.1, crs = "EPSG:32618")
# Rasterize each band to disk (this avoids huge in-memory objects)
r_b1 <- terra::rasterize(v_utm, r_empty, field = "B1", filename = "r_b1.tif", overwrite = TRUE)
r_b2 <- terra::rasterize(v_utm, r_empty, field = "B2", filename = "r_b2.tif", overwrite = TRUE)
r_b3 <- terra::rasterize(v_utm, r_empty, field = "B3", filename = "r_b3.tif", overwrite = TRUE)
# Combine bands into a multi-layer raster
rgb_raster <- c(r_b1, r_b2, r_b3)
# Reproject the multi-band raster back to WGS84 (disk-backed)
rgb_raster_wgs <- terra::project(rgb_raster, "EPSG:4326", filename = "rgb_raster_wgs.tif", overwrite = TRUE)
# Convert to a RasterBrick (suitable for leafem::addRasterRGB)
rgb_brick <- raster::brick(rgb_raster_wgs)
# Create an interactive map with leaflet and leafem
m <- leaflet() %>%
addTiles() %>%
leafem::addRasterRGB(rgb_brick, r = 1, g = 2, b = 3)
# Aggregate the RasterBrick to a coarser resolution (e.g., factor of 10)
rgb_brick_coarse <- raster::aggregate(rgb_brick, fact = 10, fun = mean)
# Create the interactive map using the aggregated (coarser) raster
m <- leaflet() %>%
addTiles() %>%
leafem::addRasterRGB(rgb_brick_coarse, r = 1, g = 2, b = 3)
htmlwidgets::saveWidget(m, "interactive_map_coarse.html")
