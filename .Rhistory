max_f_meas_table <- bind_rows(
mutate(logreg_max_f_meas, model = "Logistic Regression"),
mutate(lda_max_f_meas, model = "LDA"),
mutate(qda_max_f_meas, model = "QDA")
)
# Print the table as a knitr table with a caption
max_f_meas_table %>%
select(model, .threshold, .estimate) %>%  # Select relevant columns
rename(Threshold = .threshold, F_Measure = .estimate) %>%  # Rename for clarity
knitr::kable(
caption = "Optimal Thresholds and Corresponding F-Measures for Each Model",
digits = 3,  # Limit decimals for readability
col.names = c("Model", "Threshold", "F-Measure")
) %>%
kableExtra::kable_styling(full_width = FALSE, position = "center")
# Function to calculate F-measure performance
get_f_meas_performance <- function(model, data) {
# Augment the data with predictions
augmented_data <- model %>%
augment(data)
# Calculate F-measure across thresholds
performance <- probably::threshold_perf(
augmented_data,
truth = Hazardous,
estimate = .pred_TRUE,
thresholds = seq(0.05, 0.95, 0.01),  # Sequence of thresholds
event_level = "second",
metrics = metric_set(f_meas)  # Only calculate F-measure
)
return(performance)
}
# Calculate F-measure performance for each model
logreg_f_meas_perf <- get_f_meas_performance(logreg_model, train_data)
lda_f_meas_perf <- get_f_meas_performance(lda_model, train_data)
qda_f_meas_perf <- get_f_meas_performance(qda_model, train_data)
# Find the optimal threshold for each model
logreg_max_f_meas <- logreg_f_meas_perf %>% filter(.estimate == max(.estimate)) %>% slice(1)
lda_max_f_meas <- lda_f_meas_perf %>% filter(.estimate == max(.estimate)) %>% slice(1)
qda_max_f_meas <- qda_f_meas_perf %>% filter(.estimate == max(.estimate)) %>% slice(1)
# Combine results into a table
max_f_meas_table <- bind_rows(
mutate(logreg_max_f_meas, model = "Logistic Regression"),
mutate(lda_max_f_meas, model = "LDA"),
mutate(qda_max_f_meas, model = "QDA")
)
# Print the table as a knitr table with a caption
max_f_meas_table %>%
select(model, .threshold, .estimate) %>%  # Select relevant columns
rename(Threshold = .threshold, F_Measure = .estimate) %>%  # Rename for clarity
knitr::kable(
caption = "Optimal Thresholds and Corresponding F-Measures for Each Model",
digits = 3,  # Limit decimals for readability
col.names = c("Model", "Threshold", "F-Measure")
) %>%
kableExtra::kable_styling(full_width = FALSE, position = "center")
# Function to create F-measure plot for a given model
plot_f_meas <- function(performance_data, max_performance, model_name) {
ggplot(performance_data, aes(x = .threshold, y = .estimate)) +
geom_line(color = "blue") +  # Plot F-measure vs threshold
geom_vline(data = max_performance, aes(xintercept = .threshold), color = "red", linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 1, 0.1)) +
labs(title = model_name, x = "Threshold", y = "F-Measure") +
theme_minimal() +
theme(legend.position = "none")
}
# Generate plots for the three non-null models
g_logreg <- plot_f_meas(logreg_f_meas_perf, logreg_max_f_meas, "Logistic Regression")
g_lda <- plot_f_meas(lda_f_meas_perf, lda_max_f_meas, "LDA")
g_qda <- plot_f_meas(qda_f_meas_perf, qda_max_f_meas, "QDA")
# Arrange the plots in a single row
final_plot <- g_logreg + g_lda + g_qda
# Print the final combined plot
print(final_plot)
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(patchwork)
# Function to create F-measure plot for a given model
plot_f_meas <- function(performance_data, max_performance, model_name) {
ggplot(performance_data, aes(x = .threshold, y = .estimate)) +
geom_line(color = "blue") +  # Plot F-measure vs threshold
geom_vline(data = max_performance, aes(xintercept = .threshold),
color = "red", linetype = "dashed") +  # Add vertical line
geom_point(data = max_performance, aes(x = .threshold, y = .estimate),
color = "red", size = 3) +  # Add max F-measure point
geom_text(data = max_performance, aes(x = .threshold, y = .estimate,
label = paste0("F: ", round(.estimate, 3))),
hjust = -0.1, vjust = -0.5, color = "red", size = 4) +  # Label max F-measure
geom_text(data = max_performance, aes(x = .threshold, y = 0,
label = paste0("Threshold: ", round(.threshold, 2))),
hjust = 1.2, vjust = -1.2, color = "red", size = 4) +  # Label threshold
scale_x_continuous(breaks = seq(0, 1, 0.1)) +
labs(title = model_name, x = "Threshold", y = "F-Measure") +
theme_minimal() +
theme(legend.position = "none")
}
# Generate plots for the three non-null models
g_logreg <- plot_f_meas(logreg_f_meas_perf, logreg_max_f_meas, "Logistic Regression")
g_lda <- plot_f_meas(lda_f_meas_perf, lda_max_f_meas, "LDA")
g_qda <- plot_f_meas(qda_f_meas_perf, qda_max_f_meas, "QDA")
# Arrange the plots in a single row
final_plot <- g_logreg + g_lda + g_qda
# Print the final combined plot
print(final_plot)
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(patchwork)
# Function to create F-measure plot for a given model
plot_f_meas <- function(performance_data, max_performance, model_name) {
ggplot(performance_data, aes(x = .threshold, y = .estimate)) +
geom_line(color = "blue") +  # Plot F-measure vs threshold
geom_vline(data = max_performance, aes(xintercept = .threshold),
color = "red", linetype = "dashed") +  # Add vertical line
geom_point(data = max_performance, aes(x = .threshold, y = .estimate),
color = "red", size = 3) +  # Add max F-measure point
geom_text(data = max_performance, aes(x = .threshold, y = .estimate,
label = paste0("F: ", round(.estimate, 3))),
hjust = -0.1, vjust = -0.5, color = "red", size = 4) +  # Label max F-measure
geom_text(data = max_performance, aes(x = .threshold, y = 0,
label = paste0(round(.threshold, 2))),
hjust = 1.2, vjust = -1.2, color = "red", size = 4) +  # Label threshold
scale_x_continuous(breaks = seq(0, 1, 0.1)) +
labs(title = model_name, x = "Threshold", y = "F-Measure") +
theme_minimal() +
theme(legend.position = "none")
}
# Generate plots for the three non-null models
g_logreg <- plot_f_meas(logreg_f_meas_perf, logreg_max_f_meas, "Logistic Regression")
g_lda <- plot_f_meas(lda_f_meas_perf, lda_max_f_meas, "LDA")
g_qda <- plot_f_meas(qda_f_meas_perf, qda_max_f_meas, "QDA")
# Arrange the plots in a single row
final_plot <- g_logreg + g_lda + g_qda
# Print the final combined plot
print(final_plot)
# Function to compute evaluation metrics at the optimal threshold
compute_metrics <- function(model, data, threshold) {
# Augment the data with predictions
augmented_data <- model %>%
augment(data) %>%
mutate(.pred_class = as.factor(if_else(.pred_TRUE > threshold, "TRUE", "FALSE"))) # Apply threshold
# Compute performance metrics
metrics_table <- bind_rows(
accuracy(augmented_data, truth = Hazardous, estimate = .pred_class),
sens(augmented_data, truth = Hazardous, estimate = .pred_class),
spec(augmented_data, truth = Hazardous, estimate = .pred_class),
f_meas(augmented_data, truth = Hazardous, estimate = .pred_class)
)
return(metrics_table)
}
# Compute metrics for each model at its optimal threshold
logreg_metrics <- compute_metrics(logreg_model, test_data, logreg_max_f_meas$.threshold)
lda_metrics <- compute_metrics(lda_model, test_data, lda_max_f_meas$.threshold)
qda_metrics <- compute_metrics(qda_model, test_data, qda_max_f_meas$.threshold)
# Combine results into a single table
all_metrics <- bind_rows(
mutate(logreg_metrics, Model = "Logistic Regression"),
mutate(lda_metrics, Model = "LDA"),
mutate(qda_metrics, Model = "QDA")
) %>%
select(Model, .metric, .estimate) %>%
pivot_wider(names_from = .metric, values_from = .estimate) %>%
rename(
Accuracy = accuracy,
Sensitivity = sens,
Specificity = spec,
`F-Measure` = f_meas
)
# Print results in a formatted knitr table
knitr::kable(
all_metrics,
caption = "Model Performance Metrics at Optimal Thresholds",
digits = 3,
col.names = c("Model", "Accuracy", "Sensitivity", "Specificity", "F-Measure")
) %>%
kableExtra::kable_styling(full_width = FALSE, position = "center")
setwd("~/Documents/MSDS/DS6030/DS6030_HaitiProject_Team1")
install.packages("colordistance")
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
knitr::opts_chunk$set(fig.align="center", fig.pos="H")
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(stars)
library(colordistance)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(stars)
library(colordistance)
# Assuming "orthovnir078_makeshift_villiage1.jpg" is in your working directory
image_path <- "orthovnir078_makeshift_villiage1.jpg"
colordistance::plotPixels(image_path, lower = rep(0.8, 3), upper = rep(1, 3))
# Assuming "orthovnir078_makeshift_villiage1.jpg" is in your working directory
image_path <- "orthovnir078_makeshift_villiage1.jpg"
colordistance::plotPixels(image_path)
# Assuming "orthovnir078_makeshift_villiage1.jpg" is in your working directory
image_path <- "orthovnir078_makeshift_villiage1.jpg"
colordistance::plotPixels(image_path, lower = rep(0.8, 3), upper = rep(1, 3))
# Assuming "orthovnir078_makeshift_villiage1.jpg" is in your working directory
image_path <- "orthovnir078_makeshift_villiage1.jpg"
colordistance::plotPixels(image_path, lower = rep(0.8, 3), upper = rep(1, 3))
# Assuming "orthovnir078_makeshift_villiage1.jpg" is in your working directory
image_path <- "orthovnir078_makeshift_villiage1.jpg"
colordistance::plotPixels(image_path)
View(qda_model)
image_path <- "orthovnir078_makeshift_villiage1.jpg"
colordistance::plotPixels(image_path)
H8hist <- colordistance::getImageHist(image_path, bins=c(2, 2, 2), lower=lower, upper=upper)
image_path <- "orthovnir078_makeshift_villiage1.jpg"
colordistance::plotPixels(image_path)
H8hist <- colordistance::getImageHist(image_path, bins=c(2, 2, 2))
#| message: FALSE
image_path <- "rgb_raster_wgs.tif"
colordistance::plotPixels(image_path)
install.packages("magick")
#| message: FALSE
tif_image <- image_read("rgb_raster_wgs.tif")
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(stars)
library(colordistance)
library(magick)
#| message: FALSE
tif_image <- image_read("rgb_raster_wgs.tif")
#| message: FALSE
img_magick <- image_read("rgb_raster_wgs.tif")
#| message: FALSE
# Read the TIFF file; native = FALSE returns an R array
img <- readTIFF("rgb_raster_wgs.tif", native = FALSE)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(stars)
library(colordistance)
library(magick)
library(tiff)
install.packages("tiff")
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(stars)
library(colordistance)
library(magick)
library(tiff)
library(png)
#| message: FALSE
# Read the TIFF file; native = FALSE returns an R array
img <- readTIFF("rgb_raster_wgs.tif", native = FALSE)
library(tiff)
library(jpeg)
# Read the TIFF file; native = FALSE returns an R array with values typically in [0,1]
img <- readTIFF("rgb_raster_wgs.tif", native = FALSE)
library(terra)
library(jpeg)
# Read the GeoTIFF into a SpatRaster (this file has georeferencing info)
r <- rast("rgb_raster_wgs.tif")
# Convert the SpatRaster to an array.
# The result should be a 3D array: rows x columns x bands (assumed to be R, G, B)
img_array <- as.array(r)
# Option 1: Write the raster directly as a JPEG.
# This will use the GDAL driver based on the file extension.
terra::writeRaster(rgb_raster, "rgb_raster_wgs.jpg", overwrite = TRUE)
library(terra)
# Read the GeoTIFF into a SpatRaster (this file has georeferencing info)
rgb_raster <- rast("rgb_raster_wgs.tif")
# Write the raster directly as a JPEG using GDAL (no need to load the full array in R)
writeRaster(rgb_raster, "rgb_raster_wgs.jpg", overwrite = TRUE)
library(terra)
rgb_raster <- rast("rgb_raster_wgs.tif")
writeRaster(rgb_raster, "rgb_raster_wgs.jpg", filetype = "JPEG", overwrite = TRUE)
image_path <- "rgb_raster_wgs.jpg"
colordistance::plotPixels(image_path)
library(jpeg)
# Assume holdout_data has columns B1, B2, and B3 with values from 0 to 255
n <- nrow(holdout_data)
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
knitr::opts_chunk$set(fig.align="center", fig.pos="H")
#| cache: FALSE
#| message: FALSE
library(doParallel)
cl <- makePSOCKcluster(parallel::detectCores(logical = FALSE))
registerDoParallel(cl)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(stars)
library(colordistance)
library(magick)
library(tiff)
library(png)
#| message: FALSE
files <- c(
"orthovnir057_ROI_NON_Blue_Tarps.txt",
"orthovnir078_ROI_NON_Blue_Tarps.txt",
"orthovnir067_ROI_NOT_Blue_Tarps.txt",
"orthovnir069_ROI_NOT_Blue_Tarps.txt"
)
non_not_blue_data <- map_dfr(files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(6, 6, 10, 12, 12, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = str_extract(.x, "(NON_Blue_Tarps|NOT_Blue_Tarps)"))
})
#| message: FALSE
blue_files <- c(
"orthovnir069_ROI_Blue_Tarps.txt",
"orthovnir067_ROI_Blue_Tarps.txt",
"orthovnir078_ROI_Blue_Tarps.txt"
)
blue_data <- map_dfr(blue_files, ~ {
read_fwf(
file = .x,
col_positions = fwf_widths(
widths = c(5, 6, 10, 12, 11, 10, 12, 5, 5, 5),
col_names = c("ID", "X", "Y", "Map_X", "Map_Y", "Lat", "Lon", "B1", "B2", "B3")
),
skip = 8
) %>%
mutate(Class = "Blue_Tarps")
})
holdout_data <- bind_rows(
non_not_blue_data %>% select(Lat, Lon, B1, B2, B3, Class),
blue_data %>% select(Lat, Lon, B1, B2, B3, Class)
)
glimpse(holdout_data)
library(jpeg)
# Assume holdout_data has columns B1, B2, and B3 with values from 0 to 255
n <- nrow(holdout_data)
# Create an array of dimensions: height = n, width = 1, channels = 3 (R, G, B)
img_array <- array(0, dim = c(n, 1, 3))
# Normalize the values to 0-1 and assign to the corresponding channels
img_array[,,1] <- holdout_data$B1 / 255  # Red channel
img_array[,,2] <- holdout_data$B2 / 255  # Green channel
img_array[,,3] <- holdout_data$B3 / 255  # Blue channel
# Write the image to a JPEG file
writeJPEG(img_array, target = "holdout_colors.jpg")
library(jpeg)
# Assume holdout_data has columns B1, B2, B3 with values 0-255.
total <- nrow(holdout_data)
maxHeight <- 65500
if(total <= maxHeight) {
height <- total
width <- 1
} else {
height <- maxHeight
width <- ceiling(total / height)
}
total_pixels <- height * width
# Get color vectors and normalize to 0-1:
r_vec <- holdout_data$B1 / 255
g_vec <- holdout_data$B2 / 255
b_vec <- holdout_data$B3 / 255
# Pad the vectors if there are fewer pixels than the grid size
pad_length <- total_pixels - total
if(pad_length > 0) {
r_vec <- c(r_vec, rep(r_vec[length(r_vec)], pad_length))
g_vec <- c(g_vec, rep(g_vec[length(g_vec)], pad_length))
b_vec <- c(b_vec, rep(b_vec[length(b_vec)], pad_length))
}
# Create the image array of dimensions: height x width x 3
img_array <- array(0, dim = c(height, width, 3))
img_array[,,1] <- matrix(r_vec, nrow = height, ncol = width)
img_array[,,2] <- matrix(g_vec, nrow = height, ncol = width)
img_array[,,3] <- matrix(b_vec, nrow = height, ncol = width)
# Write the image to a JPEG file
writeJPEG(img_array, target = "holdout_colors.jpg")
image_path <- "holdout_colors.jpg"
colordistance::plotPixels(image_path)
library(jpeg)
# Number of pixels (one per row in holdout_data)
n <- nrow(holdout_data)
maxHeight <- 65500
height <- min(n, maxHeight)
width <- ceiling(n / height)
total_pixels <- height * width
# Normalize RGB values from 0-255 to 0-1
r <- holdout_data$B1 / 255
g <- holdout_data$B2 / 255
b <- holdout_data$B3 / 255
# Calculate padding needed to fill the grid
pad <- total_pixels - n
# Pad the vectors with a fixed color "010" (red = 0, green = 1, blue = 0)
if(pad > 0){
r <- c(r, rep(0, pad))
g <- c(g, rep(1, pad))
b <- c(b, rep(0, pad))
}
# Reshape each channel into a matrix and combine into a 3D array
img_array <- array(c(matrix(r, nrow = height, ncol = width),
matrix(g, nrow = height, ncol = width),
matrix(b, nrow = height, ncol = width)),
dim = c(height, width, 3))
# Write the image to a JPEG file
writeJPEG(img_array, target = "holdout_colors.jpg")
image_path <- "holdout_colors.jpg"
colordistance::plotPixels(image_path)
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(stars)
library(colordistance)
library(jpeg)
test_data <- read.csv("HaitiPixels.csv")
View(test_data)
# Number of pixels
n <- nrow(test_data)
maxHeight <- 65500
height <- min(n, maxHeight)
width <- ceiling(n / height)
total_pixels <- height * width
# Normalize RGB
r <- test_data$Red / 255
g <- holdout_data$Green / 255
b <- test_data$Blue / 255
# Calculate padding
pad <- total_pixels - n
# Pad
if(pad > 0){
r <- c(r, rep(0, pad))
g <- c(g, rep(1, pad))
b <- c(b, rep(0, pad))
}
# Make array
img_array <- array(c(matrix(r, nrow = height, ncol = width),
matrix(g, nrow = height, ncol = width),
matrix(b, nrow = height, ncol = width)),
dim = c(height, width, 3))
# Write to jpg
writeJPEG(img_array, target = "test_colors.jpg")
# Number of pixels
n <- nrow(test_data)
maxHeight <- 65500
height <- min(n, maxHeight)
width <- ceiling(n / height)
total_pixels <- height * width
# Normalize RGB
r <- test_data$Red / 255
g <- test_data$Green / 255
b <- test_data$Blue / 255
# Calculate padding
pad <- total_pixels - n
# Pad
if(pad > 0){
r <- c(r, rep(0, pad))
g <- c(g, rep(1, pad))
b <- c(b, rep(0, pad))
}
# Make array
img_array <- array(c(matrix(r, nrow = height, ncol = width),
matrix(g, nrow = height, ncol = width),
matrix(b, nrow = height, ncol = width)),
dim = c(height, width, 3))
# Write to jpg
writeJPEG(img_array, target = "test_colors.jpg")
image_path <- "test_colors.jpg"
colordistance::plotPixels(image_path)
col_names <- c('ID','X','Y','Map X','Map Y','Lat','Lon','Red','Green','Blue')
haiti_bt1 <- read_table("orthovnir067_ROI_Blue_Tarps.txt", comment=";", col_names=col_names) %>%
select(Red, Green, Blue) %>%
mutate(BT = "TRUE")
View(haiti_bt1)
