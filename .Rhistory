y = "Count",
title = "Histogram of Prediction Probabilities (RGB) (0.5 to <1)"
) +
theme_minimal()
library(ggplot2)
ggplot(holdout_data_clustering_rgb, aes(x = pred_TRUE, y = clustering_metric)) +
geom_point(alpha = 0.3, color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE) +
labs(
x = "Prediction Probability (.pred_TRUE)",
y = "Clustering Measure (Local Mean Difference)",
title = "Correlation between Prediction Probability and Clustering (RGB)"
) +
theme_minimal()
ggplot(holdout_data_clustering_rgb, aes(x = pred_TRUE, y = clustering_metric)) +
geom_point(alpha = 0.3, color = "blue") +
geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = FALSE) +
labs(
x = "Prediction Probability (.pred_TRUE)",
y = "Clustering Measure (Local Mean Difference)",
title = "Quadratic Relationship between Prediction Probability and Clustering (RGB)"
) +
theme_minimal()
save.image("~/Documents/MSDS/DS6030/DS6030_HaitiProject_Team1/haiti.RData")
# Map X and Map Y
holdout_data_sp <- holdout_data %>%
rename(x = `Map X`, y = `Map Y`)
# Convert to spatial vector
v_utm <- terra::vect(holdout_data_sp, geom = c("x", "y"), crs = "EPSG:32618")
# Create an empty raster
r_empty <- terra::rast(terra::ext(v_utm), resolution = 0.08, crs = "EPSG:32618")
# Rasterize
r_b1 <- terra::rasterize(v_utm, r_empty, field = "Red", overwrite = TRUE)
r_b2 <- terra::rasterize(v_utm, r_empty, field = "Green", overwrite = TRUE)
r_b3 <- terra::rasterize(v_utm, r_empty, field = "Blue", overwrite = TRUE)
# Combine
rgb_raster <- c(r_b1, r_b2, r_b3)
# Reproject to WGS84
rgb_raster_wgs <- terra::project(rgb_raster, "EPSG:4326", overwrite = TRUE)
# Convert to brick
rgb_brick <- raster::brick(rgb_raster_wgs)
# Create the map
m <- leaflet(options = leafletOptions(maxZoom = 25)) %>%
addTiles(options = tileOptions(maxZoom = 25)) %>%
leafem::addRasterRGB(rgb_brick, r = 1, g = 2, b = 3) %>%
# Add scale bar
addScaleBar(position = "bottomleft", options = scaleBarOptions(metric = TRUE, imperial = FALSE)) %>%
# Add easyPrint button
addEasyprint(options = easyprintOptions(
title = "Print Map",
position = "topright",
exportOnly = TRUE  # Change to FALSE for direct printing
))
Sys.setenv(R_MAX_VSIZE = 32e9)  # Set max vector memory to 32GB
# Create the map
m <- leaflet(options = leafletOptions(maxZoom = 25)) %>%
addTiles(options = tileOptions(maxZoom = 25)) %>%
leafem::addRasterRGB(rgb_brick, r = 1, g = 2, b = 3) %>%
# Add scale bar
addScaleBar(position = "bottomleft", options = scaleBarOptions(metric = TRUE, imperial = FALSE)) %>%
# Add easyPrint button
addEasyprint(options = easyprintOptions(
title = "Print Map",
position = "topright",
exportOnly = TRUE  # Change to FALSE for direct printing
))
library(stars)
rgb_stars <- st_as_stars(rgb_raster_wgs)
names(rgb_stars) <- c("Red", "Green", "Blue")
# Load required libraries
library(leaflet)
library(leafem)
library(stars)
library(terra)
# Convert terra raster stack to stars object
rgb_stars <- st_as_stars(rgb_raster_wgs)
# Check the structure of the stars object
print(rgb_stars)
# If it's a single array, ensure it's reshaped into multi-band format
if (length(dim(rgb_stars)) == 2) {
rgb_stars <- st_as_stars(
list(Red = rgb_raster_wgs[[1]],
Green = rgb_raster_wgs[[2]],
Blue = rgb_raster_wgs[[3]])
)
}
# Verify bands
names(rgb_stars) <- c("Red", "Green", "Blue")
print(rgb_stars)
# Load raster into memory
rgb_stars <- read_stars(rgb_stars)
# Load required libraries
library(leaflet)
library(leafem)
library(stars)
library(terra)
# Convert terra raster stack to stars object
rgb_stars <- st_as_stars(rgb_raster_wgs)
# Load raster into memory
rgb_stars <- read_stars(rgb_stars)
# Load required libraries
library(leaflet)
library(leafem)
library(stars)
library(terra)
# Convert terra raster stack to stars object
rgb_stars <- st_as_stars(rgb_raster_wgs)
# Assign band names
names(rgb_stars) <- c("Red", "Green", "Blue")
# Load required libraries
library(leaflet)
library(leafem)
library(stars)
library(terra)
# Convert terra raster stack to stars object
rgb_stars <- st_as_stars(rgb_raster_wgs)
# Rename band dimension
rgb_stars <- st_set_dimensions(rgb_stars, 3, values = c("Red", "Green", "Blue"))
# Verify structure
print(rgb_stars)
# Create Leaflet map
m <- leaflet(options = leafletOptions(maxZoom = 25)) %>%
addTiles(options = tileOptions(maxZoom = 25)) %>%
# Add raster image from stars
leafem::addStarsImage(rgb_stars, bands = c("Red", "Green", "Blue")) %>%
# Add scale bar
addScaleBar(position = "bottomleft", options = scaleBarOptions(metric = TRUE, imperial = FALSE)) %>%
# Add easyPrint button
addEasyprint(options = easyprintOptions(
title = "Print Map",
position = "topright",
exportOnly = TRUE
))
# Load required libraries
library(leaflet)
library(leafem)
library(stars)
library(terra)
# Convert terra raster stack to stars object
rgb_stars <- st_as_stars(rgb_raster_wgs)
# Ensure correct band dimension
rgb_stars <- st_set_dimensions(rgb_stars, "band", values = c("Red", "Green", "Blue"))
# Verify structure
print(rgb_stars)
# Create Leaflet map
m <- leaflet(options = leafletOptions(maxZoom = 25)) %>%
addTiles(options = tileOptions(maxZoom = 25)) %>%
# Add raster image from stars (set correct band order)
leafem::addStarsImage(rgb_stars, bands = 1:3) %>%
# Add scale bar
addScaleBar(position = "bottomleft", options = scaleBarOptions(metric = TRUE, imperial = FALSE)) %>%
# Add easyPrint button
addEasyprint(options = easyprintOptions(
title = "Print Map",
position = "topright",
exportOnly = TRUE
))
# Load required libraries
library(leaflet)
library(leafem)
library(stars)
library(terra)
# Convert terra raster stack to stars object
rgb_stars <- st_as_stars(rgb_raster_wgs)
# Ensure it has correct band names for Red, Green, and Blue
rgb_stars <- st_set_dimensions(rgb_stars, "band", values = c("Red", "Green", "Blue"))
# Verify structure
print(rgb_stars)
# Create Leaflet map
m <- leaflet(options = leafletOptions(maxZoom = 25)) %>%
addTiles(options = tileOptions(maxZoom = 25)) %>%
# Add raster image from stars, setting the band indices explicitly
leafem::addStarsImage(rgb_stars, band = c(1, 2, 3)) %>%
# Add scale bar
addScaleBar(position = "bottomleft", options = scaleBarOptions(metric = TRUE, imperial = FALSE)) %>%
# Add easyPrint button
addEasyprint(options = easyprintOptions(
title = "Print Map",
position = "topright",
exportOnly = TRUE
))
# Load required libraries
library(leaflet)
library(leafem)
library(stars)
library(terra)
# Convert terra raster stack to stars object (ensuring correct format)
rgb_stars <- st_as_stars(rgb_raster_wgs)
# Ensure band dimension is correctly labeled
rgb_stars <- st_set_dimensions(rgb_stars, "band", values = c("Red", "Green", "Blue"))
# Verify structure
print(rgb_stars)
# Create Leaflet map
m <- leaflet(options = leafletOptions(maxZoom = 25)) %>%
addTiles(options = tileOptions(maxZoom = 25)) %>%
# Add raster image from stars, specifying RGB bands explicitly
leafem::addStarsImage(rgb_stars, band = 1:3, colors = NULL) %>%
# Add scale bar
addScaleBar(position = "bottomleft", options = scaleBarOptions(metric = TRUE, imperial = FALSE)) %>%
# Add easyPrint button
addEasyprint(options = easyprintOptions(
title = "Print Map",
position = "topright",
exportOnly = TRUE
))
# Load required libraries
library(leaflet)
library(leafem)
library(stars)
library(terra)
# Convert terra raster stack to stars object (ensuring correct format)
rgb_stars <- st_as_stars(rgb_raster_wgs)
# Ensure band dimension is correctly labeled
rgb_stars <- st_set_dimensions(rgb_stars, "band", values = c("R", "G", "B"))
# Verify structure
print(rgb_stars)
# Create Leaflet map
m <- leaflet(options = leafletOptions(maxZoom = 25)) %>%
addTiles(options = tileOptions(maxZoom = 25)) %>%
# Add raster image from stars, specifying RGB bands explicitly
leafem::addStarsImage(rgb_stars, band = 1:3, colors = NULL) %>%
# Add scale bar
addScaleBar(position = "bottomleft", options = scaleBarOptions(metric = TRUE, imperial = FALSE)) %>%
# Add easyPrint button
addEasyprint(options = easyprintOptions(
title = "Print Map",
position = "topright",
exportOnly = TRUE
))
setwd("~/Documents/MSDS/DS6030/DS6030_HaitiProject_Team1")
load("~/Documents/MSDS/DS6030/DS6030_HaitiProject_Team1/haiti.RData")
knitr::opts_chunk$set(
echo = FALSE,
cache = TRUE,
autodep = TRUE,
fig.align = "center",
fig.pos = "H",
out.width = "100%"
)
library(dplyr)
library(ggplot2)
# Suppose we have a reference color: cornflower blue
# in RGB(0–255) is (100, 149, 237).
ref_r <- 100
ref_g <- 149
ref_b <- 237
# 1) Compute the mean local difference for each group
means_df <- combined_df_filtered %>%
group_by(group) %>%
summarize(mean_diff = mean(local_diff, na.rm = TRUE))
combined_df_filtered <- combined_df %>%
group_by(group) %>%
filter(local_diff <= quantile(local_diff, 0.80, na.rm = TRUE)) %>%
ungroup()
#| cache: FALSE
#| message: FALSE
library(doParallel)
cl <- makePSOCKcluster(parallel::detectCores(logical = FALSE))
registerDoParallel(cl)
#| cache: FALSE
#| warning: FALSE
#| message: FALSE
library(tidyverse)
library(tidymodels)
library(discrim)
library(leaflet)
library(terra)
library(htmlwidgets)
library(leafem)
library(colordistance)
library(jpeg)
library(patchwork)
library(probably)
library(gridExtra)
library(plotly)
library(mapview)
library(farver)
library(kableExtra)
library(leaflet.extras2)
library(webshot2)
load("~/Documents/MSDS/DS6030/DS6030_HaitiProject_Team1/haiti.RData")
# Suppose we have a reference color: cornflower blue
# in RGB(0–255) is (100, 149, 237).
ref_r <- 100
ref_g <- 149
ref_b <- 237
# 1) Compute the mean local difference for each group
means_df <- combined_df_filtered %>%
group_by(group) %>%
summarize(mean_diff = mean(local_diff, na.rm = TRUE))
# For convenience, extract them as numeric values
mean_orig <- means_df$mean_diff[means_df$group == "Original"]
mean_rand <- means_df$mean_diff[means_df$group == "Randomized"]
# 2) Define a helper function to shift each channel by +/- shift
#    Then clamp to [0, 255] and return a hex color string
shiftColorRGB <- function(r, g, b, shift) {
r2 <- min(max(r + shift, 0), 255)
g2 <- min(max(g + shift, 0), 255)
b2 <- min(max(b + shift, 0), 255)
grDevices::rgb(r2 / 255, g2 / 255, b2 / 255)
}
# 3) Create a small data frame with four swatches:
#    * Original minus mean
#    * Original plus mean
#    * Randomized minus mean
#    * Randomized plus mean
swatch_data <- data.frame(
scenario = c("Original - mean", "Original + mean",
"Randomized - mean", "Randomized + mean"),
color_hex = c(
shiftColorRGB(ref_r, ref_g, ref_b, -mean_orig),
shiftColorRGB(ref_r, ref_g, ref_b,  mean_orig),
shiftColorRGB(ref_r, ref_g, ref_b, -mean_rand),
shiftColorRGB(ref_r, ref_g, ref_b,  mean_rand)
)
)
# 4) Plot these four swatches side by side
ggplot(swatch_data, aes(x = scenario, y = 1, fill = color_hex)) +
geom_col(width = 0.8) +
scale_fill_identity() +
labs(
title = "Illustration of Mean Shifts in Color (Cornflower Blue ± Mean)",
x = "",
y = ""
) +
theme_minimal() +
theme(axis.text.y = element_blank(),
axis.ticks.y = element_blank())
library(ggplot2)
library(dplyr)
# 1. Reference color: cornflower blue (RGB in [0..255])
ref_r <- 100
ref_g <- 149
ref_b <- 237
# 2. Suppose these are the mean Euclidean distances from your data
mean_orig <- 20  # example
mean_rand <- 40  # example
# 3. A helper function that shifts each channel ± s, where s = distance / sqrt(3)
#    This ensures the resulting color is exactly 'distance' away in Euclidean RGB space.
#    For "plus" shift, sign=+1, for "minus" shift, sign=-1.
shiftColorEuclidean <- function(r, g, b, distance, sign = c("plus", "minus")) {
sign <- match.arg(sign)
# The shift s to apply to each channel
s <- distance / sqrt(3)
if (sign == "minus") s <- -s
r2 <- min(max(r + s, 0), 255)
g2 <- min(max(g + s, 0), 255)
b2 <- min(max(b + s, 0), 255)
# Convert to a hex color
grDevices::rgb(r2 / 255, g2 / 255, b2 / 255)
}
# 4. Build a small data frame with four swatches:
#    * Original - mean
#    * Original + mean
#    * Randomized - mean
#    * Randomized + mean
swatch_data <- data.frame(
scenario = c("Original - mean", "Original + mean",
"Randomized - mean", "Randomized + mean"),
# For each scenario, we compute the shifted color
color_hex = c(
shiftColorEuclidean(ref_r, ref_g, ref_b, mean_orig, "minus"),
shiftColorEuclidean(ref_r, ref_g, ref_b, mean_orig, "plus"),
shiftColorEuclidean(ref_r, ref_g, ref_b, mean_rand, "minus"),
shiftColorEuclidean(ref_r, ref_g, ref_b, mean_rand, "plus")
),
# Also store the numeric distance we used
distance = c(-mean_orig, mean_orig, -mean_rand, mean_rand)
)
# 5. Plot these swatches side by side
ggplot(swatch_data, aes(x = scenario, y = 1, fill = color_hex)) +
geom_col(width = 0.8) +
scale_fill_identity() +
geom_text(aes(label = distance),
color = "white", size = 4, vjust = 1.5) +
labs(
title = "Shifting Each RGB Channel to Achieve a Specified Euclidean Distance",
x = "",
y = ""
) +
theme_minimal() +
theme(axis.text.y = element_blank(),
axis.ticks.y = element_blank())
combined_df_filtered <- combined_df %>%
group_by(group) %>%
filter(local_diff <= quantile(local_diff, 0.80, na.rm = TRUE)) %>%
ungroup()
# Create a box plot comparing the two groups.
ggplot(combined_df_filtered, aes(x = group, y = local_diff, fill = group)) +
geom_boxplot(alpha = 0.7) +
labs(
title = "Comparison of Local Euclidean Differences\n(Original vs. Randomized Spatial Arrangement)",
x = "Data Type",
y = "Euclidean Difference from Local Mean"
) +
theme_minimal() +
scale_fill_manual(values = c("blue", "red"))
# 3×3 moving window
window_size <- matrix(1, nrow = 5, ncol = 5)
# Apply focal mode filtering with NA treated as 0, but only computing for non-NA cells
smoothed_rgb_5 <- focal(r_rgb, w = window_size, fun = modal, na.policy = "omit", fillvalue = 0)
# Create empty raster
raster_template <- rast(ext(logreg_rgb_utm), resolution = 0.08, crs = "EPSG:32618")
# Function to predict class
predict_at_threshold_raster <- function(model, data, threshold) {
predictions <- model %>%
augment(data) %>%
mutate(.pred_class = make_two_class_pred(.pred_TRUE, c("TRUE", "FALSE"), threshold = threshold))
return(predictions)
}
# Apply model preds
logreg_rgb_predictions <- predict_at_threshold_raster(final_logreg_rgb_fit, holdout_data, logreg_rgb_fine_holdout_threshold)
logreg_lab_predictions <- predict_at_threshold_raster(final_logreg_lab_fit, holdout_data, logreg_lab_fine_holdout_threshold)
# Convert to spatial vector
logreg_rgb_vect <- vect(logreg_rgb_predictions, geom = c("Map X", "Map Y"), crs = "EPSG:32618")
logreg_lab_vect <- vect(logreg_lab_predictions, geom = c("Map X", "Map Y"), crs = "EPSG:32618")
# Reproject to UTM
logreg_rgb_utm <- project(logreg_rgb_vect, "EPSG:32618")
logreg_lab_utm <- project(logreg_lab_vect, "EPSG:32618")
# Create empty raster
raster_template <- rast(ext(logreg_rgb_utm), resolution = 0.08, crs = "EPSG:32618")
# Rasterize
r_rgb <- rasterize(logreg_rgb_utm, raster_template, field = ".pred_class")
r_lab <- rasterize(logreg_lab_utm, raster_template, field = ".pred_class")
# Convert to integer
r_rgb <- round(r_rgb)
r_lab <- round(r_lab)
# 3×3 moving window
window_size <- matrix(1, nrow = 5, ncol = 5)
# Apply focal mode filtering with NA treated as 0, but only computing for non-NA cells
smoothed_rgb_5 <- focal(r_rgb, w = window_size, fun = modal, na.policy = "omit", fillvalue = 0)
smoothed_lab_5 <- focal(r_lab, w = window_size, fun = modal, na.policy = "omit", fillvalue = 0)
convert_smoothed_to_df <- function(smoothed_raster, holdout_data) {
# Convert to terra
holdout_vect <- terra::vect(holdout_data, geom = c("Lon", "Lat"), crs = "EPSG:4326")
# Reproject
holdout_vect_utm <- terra::project(holdout_vect, crs(smoothed_raster))
# Extract raster values
extracted_values <- terra::extract(smoothed_raster, holdout_vect_utm, ID = FALSE)
# .pred_class
results <- holdout_data %>%
mutate(
.pred_class = factor(
extracted_values[, 1],
levels = c(1, 0),
labels = c("TRUE", "FALSE")
)
) %>%
drop_na()
return(results)
}
# Apply function
smoothed_rgb_df_5 <- convert_smoothed_to_df(smoothed_rgb_5, holdout_data)
convert_smoothed_to_df <- function(smoothed_raster, holdout_data) {
# Convert to terra
holdout_vect <- terra::vect(holdout_data, geom = c("Map X", "Map Y"), crs = "EPSG:32618")
# Reproject
holdout_vect_utm <- terra::project(holdout_vect, crs(smoothed_raster))
# Extract raster values
extracted_values <- terra::extract(smoothed_raster, holdout_vect_utm, ID = FALSE)
# .pred_class
results <- holdout_data %>%
mutate(
.pred_class = factor(
extracted_values[, 1],
levels = c(1, 0),
labels = c("TRUE", "FALSE")
)
) %>%
drop_na()
return(results)
}
# Apply function
smoothed_rgb_df_5 <- convert_smoothed_to_df(smoothed_rgb_5, holdout_data)
smoothed_lab_df_5 <- convert_smoothed_to_df(smoothed_lab_5, holdout_data)
# Function for smoothed preds
evaluate_smoothed_predictions <- function(smoothed_df, model_name, color_space) {
f_meas_score <- f_meas(smoothed_df, truth = BT, estimate = .pred_class)
tibble(
color_space = color_space,
model = model_name,
f_meas = f_meas_score$.estimate
)
}
# Compute F-measure
smoothed_metrics_5 <- bind_rows(
evaluate_smoothed_predictions(smoothed_rgb_df_5, "Logistic Regression", "RGB"),
evaluate_smoothed_predictions(smoothed_lab_df_5, "Logistic Regression", "CIELab")
)
# Display
smoothed_metrics_5 <- smoothed_metrics_5 %>%
knitr::kable(
caption = "F-Measure for Smoothed Predictions (RGB & CIELab)",
digits = 4
) %>%
kableExtra::kable_styling(full_width = FALSE)
smoothed_metrics_5
save_kable(smoothed_metrics_5, file = "smoothed_metrics_5.png", zoom = 2)
# Function of conf mats
visualize_conf_mat_smoothed <- function(smoothed_df, model_name, color_space) {
cm <- conf_mat(smoothed_df, truth = BT, estimate = .pred_class)
autoplot(cm, type = "heatmap") +
labs(title = sprintf("%s (%s) \nSmoothed", model_name, color_space))
}
# Generate
logreg_cm_rgb_smoothed_5 <- visualize_conf_mat_smoothed(smoothed_rgb_df_5, "Logistic Regression", "RGB")
logreg_cm_lab_smoothed_5 <- visualize_conf_mat_smoothed(smoothed_lab_df_5, "Logistic Regression", "CIELab")
# Combine
combined_cm_smoothed_5 <- logreg_cm_rgb_smoothed_5 + logreg_cm_lab_smoothed_5 +
plot_annotation(title = "Holdout Set Confusion Matrices for Smoothed Predictions")
combined_cm_smoothed_5
ggsave("combined_cm_smoothed_5.png", plot = combined_cm_smoothed_5, width = 9, height = 4, dpi = 600)
